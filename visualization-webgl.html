<!DOCTYPE html>
<html lang="en">

<body style="background-color:#000000">
    <div id="canvasContainer">
        <canvas id="myCanvas" width="500" height="500" style="border:1px solid aliceblue"></canvas>
    </div>
</body>

<script>
    const canvas = document.getElementById("myCanvas");
    if (!canvas.getContext) {
        alert("canvas not supported by browser");
    }

    const gl = canvas.getContext("webgl2", {
            antialias: false,
            alpha: true,
            premultipliedAlpha: false,
    });

    const MAX_SUBATOMS = 16;

    var protons = new Float32Array(MAX_SUBATOMS * 2);
    var protonsLength = 0;
    var electrons = new Float32Array(MAX_SUBATOMS * 2);
    var electronsLength = 0;

    var vertexShaderSrc = `#version 300 es
    in vec2 position;

    void main() {
    // position specifies only x and y.
    // We set z to be 0.0, and w to be 1.0
    gl_Position = vec4(position, 0.0, 1.0);
    }
    `;

    var fragmentShaderSrc = `#version 300 es
    #define MAX_SUBATOMS ${MAX_SUBATOMS}
    precision highp float;

        
        out vec4 fragColor;

        uniform int numProtons;
        uniform int numElectrons;
        uniform vec2[MAX_SUBATOMS] protons;
        uniform vec2[MAX_SUBATOMS] electrons;

        
        float scaleToRGB(in float val) {
            return (val + 1.0) / 2.0;
        }

        void main(){
            float x = gl_FragCoord.x;
            float y = gl_FragCoord.y;

            vec2 fieldVec = vec2(0,0);
            for (int i = 0; i < numProtons; i++) {
                vec2 subatom = protons[i];
                float dx = subatom.x - x;
                float dy = subatom.y - y;
                float dist = sqrt(x*x + y*y);
                float strength = 1.0/(x*x + y*y);
                
                fieldVec += vec2(dx/dist, dy/dist) * strength;
            }

            for (int i = 0; i < numElectrons; i++) {
                vec2 subatom = electrons[i];
                float dx = subatom.x - x;
                float dy = subatom.y - y;
                float dist = sqrt(x*x + y*y);
                float strength = 1.0/(x*x + y*y);
                
                fieldVec -= vec2(dx/dist, dy/dist) * strength;
            }
            
            float finalStrength = length(fieldVec);

            fragColor = vec4(scaleToRGB(fieldVec.x/finalStrength), scaleToRGB(fieldVec.y/finalStrength), 1.0, 1.0);
        }
    `;

    const vertexShader = compileShader(vertexShaderSrc, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    var vertexData = new Float32Array([
        -1.0,  1.0, // top left
        -1.0, -1.0, // bottom left
        1.0,  1.0, // top right
        1.0, -1.0, // bottom right
    ]);
    var vertexDataBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexDataBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
    
    const protonsNumUniform = gl.getUniformLocation(program, "numProtons");
    const electronsNumUniform = gl.getUniformLocation(program, "numElectrons");
    const electronsUniform = gl.getUniformLocation(program, "electrons");
    const protonsUniform = gl.getUniformLocation(program, "protons");

    function render() {
        gl.viewport(0, 0, canvas.width, canvas.height)
        gl.clearColor(0, 0, 0, 0)
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform1i(protonsNumUniform, protonsLength);
        gl.uniform1i(electronsNumUniform, electronsLength);
        gl.uniform2fv(electronsUniform, electrons);
        gl.uniform2fv(electronsUniform, protons);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function compileShader(shaderSource, shaderType) {

        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw `${shaderSource} Shader compile failed with: ${gl.getShaderInfoLog(shader)}`;
        }

        return shader;
    }

    
    function getAttribLocation(program, name) {
        var attributeLocation = gl.getAttribLocation(program, name);
        if (attributeLocation === -1) {
            throw 'Can not find attribute ' + name + '.';
        }
        return attributeLocation;
    }

    function formatSubatomData(protons, electrons) {
        var array = [];

        array.push(protons.length);
        array.push.apply(array, protons.flat());
        array.push(electrons.length);
        array.push.apply(array, electrons.flat());

        return array;
    }

    electrons[0] = 0.0;
    electrons[1] = 0.0;
    electronsLength = 1;

    render();
</script>